import csv
import numpy as np
from PIL import Image, ImageEnhance, ImageFilter
import os
import pywt
from noise import pnoise2
from skimage.filters import gaussian

# Function to generate and save the image from CSV row data
def generate_image_from_row(row_dict, output_folder_path):
    # Get the image name from 'family' and 'hash' keys (same as first code)
    family = row_dict.get('family', 'unknown')
    file_hash = row_dict.get('hash', 'nohash')
    image_name = f"{family}_{file_hash}.png"

    # Extract only numeric features (ignore 'hash' and 'family')
    features = [float(value) for key, value in row_dict.items()
                if key not in ['hash', 'family'] and str(value).replace('.', '', 1).isdigit()]

    if len(features) == 0:
        print(f"⚠️ No valid numeric features for {image_name}")
        return

    # Dynamic range normalization using mean ± 2.5*std (tighter focus)
    mean_val = np.mean(features)
    std_val = np.std(features)
    dynamic_min = max(0, mean_val - 2.5 * std_val)
    dynamic_max = mean_val + 2.5 * std_val
    normalized_features = np.clip(features, dynamic_min, dynamic_max)
    normalized_features = (normalized_features - dynamic_min) / (dynamic_max - dynamic_min) * 255

    # Apply sigmoid function for balanced grey scaling
    sigmoid_features = 255 / (1 + np.exp(-0.05 * (normalized_features - 127.5)))  # Adjusted slope

    # Pad to nearest square dimension
    total_elements = len(sigmoid_features)
    side_length = int(np.ceil(np.sqrt(total_elements)))
    padded_features = list(sigmoid_features) + [mean_val / (dynamic_max - dynamic_min) * 255] * (side_length * side_length - total_elements)
    reshaped_features = np.array(padded_features).reshape((side_length, side_length))

    # Gaussian blur to smooth transitions
    blurred_features = gaussian(reshaped_features / 255.0, sigma=0.6) * 255

    # Add controlled random noise
    random_noise = np.random.normal(0, 20, reshaped_features.shape)
    
    # Add structured Perlin noise for organic patterns
    x = np.linspace(0, 5, side_length)
    y = np.linspace(0, 5, side_length)
    x, y = np.meshgrid(x, y)
    perlin_noise = np.array([[pnoise2(x[i, j], y[i, j], octaves=6, persistence=0.5) 
                            for j in range(side_length)] for i in range(side_length)])
    perlin_noise = (perlin_noise - perlin_noise.min()) / (perlin_noise.max() - perlin_noise.min()) * 50

    # Combine feature data with noises
    noisy_features = blurred_features + random_noise + perlin_noise
    noisy_features = np.clip(noisy_features, 0, 255).astype(np.uint8)

    # Wavelet transform for pattern enhancement
    coeffs = pywt.dwt2(noisy_features / 255.0, 'db1')
    cA, (cH, cV, cD) = coeffs
    cH_enhanced = cH * 1.5  # Horizontal details
    cV_enhanced = cV * 1.5  # Vertical details
    cD_enhanced = cD * 1.5  # Diagonal details
    enhanced_coeffs = (cA, (cH_enhanced, cV_enhanced, cD_enhanced))
    wavelet_enhanced = pywt.idwt2(enhanced_coeffs, 'db1') * 255
    wavelet_enhanced = np.clip(wavelet_enhanced, 0, 255).astype(np.uint8)

    # Convert to PIL Image
    image = Image.fromarray(wavelet_enhanced, mode='L')

    # Post-processing (same as original)
    image = ImageEnhance.Contrast(image).enhance(2.8)
    image = ImageEnhance.Brightness(image).enhance(1.3)
    image = image.filter(ImageFilter.UnsharpMask(radius=1.5, percent=300, threshold=2))
    image = image.filter(ImageFilter.SHARPEN)

    # Save the image (same path structure as first code)
    if not os.path.exists(output_folder_path):
        os.makedirs(output_folder_path)
    output_path = os.path.join(output_folder_path, image_name)
    image.save(output_path)
    print(f"✅ Saved: {output_path} | Size: {side_length}x{side_length}")

# ---------- Main Code (Same as First Example) ----------
input_csv = r'H:\2025_Malware\all_10_csv_output\all_csv_files.csv'
output_folder = r'H:\2025_Malware\all_10_csv_output\output_images_11'

with open(input_csv, 'r', encoding='utf-8') as file:
    reader = csv.DictReader(file)
    for row in reader:
        generate_image_from_row(row, output_folder)
